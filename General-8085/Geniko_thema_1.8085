	IN 10H
	CALL RST_ALL	;Καλούμε ρουτίνα αρχικοποίησης
	PUSH PSW	;πριν από την κλήση της ρουτίνας
	PUSH B
	PUSH D
	PUSH H		;Φυλάσσουμε όλους τους καταχωρητές γιατί η STDM τους πειράζει
	CALL STDM	;Σβήνουμε την οθόνη
	POP H
	POP D
	POP B
	POP PSW
START:
	
	LXI H,0A01H	;Φορτώνουμε τη θέση μνήμης όπου θέλουμε να δουλέψει 
	CALL READ_IN	;η ρουτίνα ανάγνωσης και την καλούμε για τον πρώτο αριθμό εισόδου
READ_OP:			
	CALL KIND	;Διαβάζουμε το πρόσημο
	CPI 81H	;Ελέγχουμε αν πατήθηκε το DECR
	JZ MINUS	;Αν είναι πλην βάζουμε στον (C) το 1
	CPI 85H	;Ελέγχουμε αν πατήθηκε το FETCH PC
	JZ CONT
	JMP READ_OP	;Απορρίπτουμε οποιοδήποτε άλλο κουμπί
CONT:
	LXI H,0A05H		
	CALL READ_IN	;Διαβάζουμε τον δεύτερο αριθμό εισόδου
	LXI H,0A05H	;Φορτώνουμε τη θέση μνήμης όπου θέλουμε να δουλέψει 
	CALL CONVERT	;η ρουτίνα μετατροπής του δεκαδικού σε δεκαεξαδικό
	MOV D,A	;Κρατάμε τη μια είσοδο στον (D)
	LXI H,0A01H
	CALL CONVERT	;Μετατρέπουμε και τον δεύτερο
	MOV E,A	;Τον κρατάμε στον (Ε)
	MOV A,C	;Ελέγχουμε ποια πράξη έχει πραγματοποιηθεί
	RAR
	JNC SUM	;Αν είναι αφαίρεση	
	MOV A,D	;Ελέγχουμε ποιος είναι μεγαλύτερος
	CMP E
	JC SWAP	;Αν (Ε)>(D) κάνουμε (D)-(E)
	SUB E		;Αλλιώς (E)-(D)
	MOV B,A	;Κρατάμε το αποτέλεσμα στον (Β)
	JMP RESULT
SWAP:
	MOV A,E
	SUB D
	MOV B,A	;Κρατάμε το αποτέλεσμα στον (Β)
	JMP RESULT
SUM:			;Αν είναι πρόσθεση απλά προσθέτουμε
	MOV A,D
	ADD E
	MOV B,A	;Κρατάμε το αποτέλεσμα στον (Β)
RESULT:
	RAR			
	RAR
	RAR
	RAR		;Κάνουμε 4 ολισθήσεις και περνάμε μέσα από μια μάσκα
	ANI 0FH	;το αποτέλεσμα ώστε να κρατήσουμε τα 4 MSB
	LXI H,0A03H
	MOV M,A	;Τα βάζουμε στη θέση μνήμης που πρέπει ώστε να τα εμφανίσουμε
	MOV A,B
	ANI 0FH	;Κρατάμε τα 4  LSB 
	DCX H
	MOV M,A	;Και τα βάζουμε στην αντίστοιχη θέση μνήμης
	LXI D,0A00H	;Βάζουμε στον (D)-(E) τη θέση μνήμης όπου ξεκινούν τα αποτελέσματα
	CALL STDM	;και τα εμφανίζουμε
	CALL BEEP	;Ειδοποιούμε το χρήστη ότι μπορεί να βάλει νέα δεδομένα
	CALL RST_ALL	;Αρχικοποιούμε όλους τους καταχωρητές σε κάθε εκτέλεση
	JMP START	;Δημιουργούμε συνεχή λειτουργία
MINUS:
	MVI C,01H
	JMP CONT

READ_IN:		;Ρουτίνα ανάγνωσης διψήφιου δεκαδικού
	CALL KIND	;Διαβάζουμε από το πληκτρολόγιο
	CPI 0AH	;Κοιτάμε αν είναι δεκαδικό ψηφίο
	JNC READ_IN	;Περιμένουμε μέχρι να έρθει ένα έγκυρο ψηφίο
	MOV M,A	;Το κρατάμε στη θέση μνήμης όπου πρέπει να έχει καθοριστεί
	PUSH PSW	;πριν από την κλήση της ρουτίνας
	PUSH B
	PUSH D
	PUSH H		;Φυλάσσουμε όλους τους καταχωρητές γιατί η SRDM του πειράζει
	CALL STDM	;Εμφανίζουμε το αποτέλεσμα 
	POP H
	POP D
	POP B
	POP PSW
	CALL DCD
READ_SCND:		;Κάνουμε το ίδιο και για το δεύτερο ψηφίο
	CALL KIND
	CPI 0AH
	JNC READ_SCND 	
	DCX H		;Το δεύτερο ψηφίο αποθηκεύεται στην προηγούμενη θέση μνήμης
	MOV M,A
	PUSH PSW
	PUSH B
	PUSH D
	PUSH H
	CALL STDM
	POP H
	POP D
	POP B
	POP PSW	
	CALL DCD
	RET

CONVERT: 		;Ρουτίνα μετατροπής δεκαδικού σε δεκαεξαδικό
	MVI A,00H	;Μηδενίζουμε τον (Α)
	MOV B,M	;Φέρνουμε τις δεκάδες από τη μνήμη που έχει οριστεί πριν την κλήση της ρουτίνας
	INR B		;Αυξάνουμε τον αριθμό των δεκάδων κατά 1 ώστε να δουλέψει η
LOOP1:			;επανάληψη σε περίπτωση που έχουμε 0 δεκάδες
	ADI 0AH	;Για κάθε δεκάδα προσθέτουμε 10 στον (Α)
	DCR B		
	JNZ LOOP1
	SBI 0AH	;Αφαιρούμε 10 λογω της πλεονάζουσας δεκάδας που προσθέσαμε
	DCX H		;Παίρνουμε από την προηγούμενη θέση μνήμης τις μονάδες
	MOV B,M
	ADD B		;Και τις προσθέτουμε
	RET

RST_ALL:		;Ρουτίνα αρχικοποίησης καταχωρητων
	MVI A,00H
	LXI B,0000H
	LXI D,0A00H
	LXI H,0A00H	;Βάζουμε σε 6 διαδοχικές θέσεις μνήμης το 10H ώστε να κρατήσουμε 
	MVI M,10H	;σβηστό το display
	INX H
	MVI M,10H
	INX H
	MVI M,10H
	INX H
	MVI M,10H
	INX H
	MVI M,10H
	INX H
	MVI M,10H
	RET
END
